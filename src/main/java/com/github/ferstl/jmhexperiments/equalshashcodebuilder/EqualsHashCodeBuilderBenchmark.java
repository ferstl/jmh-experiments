package com.github.ferstl.jmhexperiments.equalshashcodebuilder;

import java.util.Arrays;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Threads;
import org.openjdk.jmh.results.format.ResultFormatType;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import com.github.ferstl.jmhexperiments.ChartFucker;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class EqualsHashCodeBuilderBenchmark {

  public static void main(String[] args) throws RunnerException {
    Options options = new OptionsBuilder()
      .include(".*EqualsHashCodeBuilderBenchmark.*")
      .warmupIterations(10)
      .measurementIterations(10)
      .resultFormat(ResultFormatType.CSV)
      .result("equals-hashcode-builder.csv")
      .build();

    new Runner(options).run();

    ChartFucker.fuck(options.getResult().orElse("equals-hashcode-builder.csv"));
  }

  @Fork(value = 1, jvmArgs = {/*"-XX:+UnlockCommercialFeatures", "-XX:+FlightRecorder", "-XX:FlightRecorderOptions=defaultrecording=true,settings=profile.jfc,dumponexit=true,dumponexitpath=equals.jfr"*/})
  @Benchmark
  public boolean equalsBaseline(TestState state) {
    return state.equalsPlain(state);
  }

  @Fork(1)
  @Benchmark
  public boolean equalsBuilder(TestState state) {
    return state.equalsWithBuilder(state);
  }

  @Fork(1)
  @Benchmark
  public int hashCodeBaseline(TestState state) {
    return state.hashCodePlain();
  }

  @Fork(1)
  @Benchmark
  public int hashCodeBuilder(TestState state) {
    return state.hashCodeWithBuilder();
  }

  @Fork(value = 1, jvmArgs = {/*"-XX:+UnlockCommercialFeatures", "-XX:+FlightRecorder", "-XX:FlightRecorderOptions=defaultrecording=true,settings=profile.jfc,dumponexit=true,dumponexitpath=equals-contended.jfr"*/})
  @Threads(5)
  @Benchmark
  public boolean equalsBaselineContended(TestState state) {
    return state.equalsPlain(state);
  }

  @Fork(1)
  @Threads(5)
  @Benchmark
  public boolean equalsBuilderContended(TestState state) {
    return state.equalsWithBuilder(state);
  }

  @Fork(1)
  @Threads(5)
  @Benchmark
  public int hashCodeBaselineContended(TestState state) {
    return state.hashCodePlain();
  }

  @Fork(1)
  @Threads(5)
  @Benchmark
  public int hashCodeBuilderContended(TestState state) {
    return state.hashCodeWithBuilder();
  }

  // Just to verify that the implementations produce correct results
  public static void testImplementation() {
    TestState state = new TestState();
    state.setup();

    System.out.println(state.equalsPlain(state));
    System.out.println(state.equalsWithBuilder(state));
    System.out.println(state.hashCodePlain());
    System.out.println(state.hashCodeWithBuilder());
    System.out.println(state.hashCodePlain());
    System.out.println(state.hashCodeWithBuilder());
  }

  @State(Scope.Thread)
  public static class TestState {

    long l1;
    long l2;
    double d1;
    double d2;
    String s1;
    String s2;
    String[] array1;
    String[] array2;

    @Setup(Level.Trial)
    public void setup() {
      Random random = new Random();

      this.array1 = new String[20];
      this.array2 = new String[20];
      for (int i = 0; i < this.array1.length; i++) {
        this.array1[i] = createRandomString(random, 20);
        this.array2[i] = new String(this.array1[i]);
      }

      this.l1 = random.nextLong();
      this.l2 = this.l1;
      this.d1 = random.nextDouble();
      this.d2 = this.d1;
      this.s1 = createRandomString(random, 200);
      this.s2 = new String(this.s1);
    }

    public boolean equalsPlain(Object o) {
      if (!(o instanceof TestState)) { return false; }

      TestState other = (TestState) o;
      return this.l1 == other.l2
          && this.d1 == other.d2
          && Objects.equals(this.s1, other.s2)
          && Arrays.equals(this.array1, other.array2);
    }

    // generated by Eclipse
    public int hashCodePlain() {
      final int prime = 31;
      int result = 1;
      result = prime * result + Arrays.hashCode(this.array1);
      long temp;
      temp = Double.doubleToLongBits(this.d1);
      result = prime * result + (int) (temp ^ (temp >>> 32));
      result = prime * result + (int) (this.l1 ^ (this.l1 >>> 32));
      result = prime * result + ((this.s1 == null) ? 0 : this.s1.hashCode());
      return result;
    }

    public boolean equalsWithBuilder(Object o) {
      if (!(o instanceof TestState)) { return false; }

      TestState other = (TestState) o;

      return new EqualsBuilder()
        .append(this.l1, other.l2)
        .append(this.d1, other.d2)
        .append(this.s1, other.s2)
        .append(this.array1, other.array2)
        .isEquals();
    }

    public int hashCodeWithBuilder() {
      return new HashCodeBuilder()
        .append(this.l1)
        .append(this.d1)
        .append(this.s1)
        .append(this.array1)
        .toHashCode();
    }

    private String createRandomString(Random random, int size) {
      char[] chars = new char[size];
      for (int i = 0; i < chars.length; i++) {
        chars[i] = (char) (random.nextInt(57) + 65);
      }

      return new String(chars);
    }
  }

}
